const Node = require("./node")
const printHelpers = require("./print_helpers")

class BST {
  constructor(initialPopulation=[]) {
    this.root = null
    this._length = 0

    if (initialPopulation.length > 0) {
      this.root = new Node(initialPopulation[0])
      this._length++
      initialPopulation.slice(1).forEach( function initialPopulator(n) {
        this.root.attachNode( new Node(n) )
        this._length++
      }.bind(this))
    }
  }

  insert(val) {
    this._length++

    if (this.root === null) {
      this.root = new Node(val)
      return this.root
    }

    return this.root.attachNode(new Node(val))
  }

  length() {
    return this._length;
  }

  getMax(currentNode=this.root) {
    while (currentNode && currentNode.right) {
      currentNode = currentNode.right
    }

    return currentNode.value
  }

  getMin(currentNode = this.root) {
    if (!this.root) return null

    while (currentNode && currentNode.left) {
      currentNode = currentNode.left
    }

    return currentNode.value
  }

  depth() {
    const depthFromNode = (startingNode) => {
      if ( !startingNode ) return 0

      return Math.max(
        1 + depthFromNode(startingNode.left),
        1 + depthFromNode(startingNode.right)
      )
    }

    return (!this.root) ? 0 : depthFromNode(this.root)
  }

  findNode(soughtValue, currentNode = this.root) {
    while (currentNode) {
      if (currentNode.value === soughtValue) return currentNode;
      currentNode = (soughtValue < currentNode.value) ? currentNode.left : currentNode.right
    }

    return null
  }

  contains(soughtValue) {
    return !!this.findNode(soughtValue)
  }

  projectDeletion(valueForRemoval) {
    if (!valueForRemoval) throw("BST#projectDelection: Must be provided value for removal!")

    const [deletionNode, parentNode] = this.findNodeAndParentNode(valueForRemoval)
    const replacementNodeValue = this.getMax(deletionNode.left)
    return [deletionNode, parentNode, ...this.findNodeAndParentNode(replacementNodeValue)]
  }

  findNodeAndParentNode(matchingValue, currentNode=this.root) {
    let parentNode = null

    while (currentNode.value !== matchingValue) {
      parentNode = currentNode
      currentNode = (matchingValue < currentNode.value) ?
        currentNode.left : currentNode.right
    }

    return [currentNode, parentNode]
  }

  removeNode(soughtValue) {
    if (!this.contains(soughtValue)) throw(`The value ${soughtValue} is not in this tree`)
    let [currentNode, parentNode, apexNode, apexParentNode] = this.projectDeletion(soughtValue)

    if (currentNode.left === null && currentNode.right === null) {
      parentNode.removeChildWithValue(currentNode.value)
    } else if (currentNode.left && !currentNode.right) {
      currentNode.value = currentNode.left.value
      currentNode.removeChildWithValue(currentNode.left.value)
    } else {
      let tempNode = new Node(apexNode.value)
      tempNode.left = currentNode.left
      tempNode.right = currentNode.right

      apexParentNode.removeChildWithValue(apexNode.value)

      parentNode.removeChildWithValue(soughtValue)
      parentNode.attachNode(tempNode)
    }

    this._length--
  }

  printBFS(helper = printHelpers.graphVizPrintHelper) {
    if (!this.root) {
      console.log("Can't print empty tree")
      return
    }

    let queue = [this.root]
    let node

    helper.pre()
    while (queue.length > 0) {
      let child1, child2;
      let node = queue.shift()

      if (node.left) {
        child1 = node.left.value
        queue.push(node.left)
      } else {
        child1 = "NULL"
      }

      if (node.right) {
        child2 = node.right.value
        queue.push(node.right)
      } else {
        child2 = "NULL"
      }

      helper.per(node, child1, child2)
    }

    helper.post({
      depth: this.depth(),
      isFull: this.isFull(),
      isPerfect: this.isPerfect(),
      min: this.getMin(),
      max: this.getMax(),
      contains2: this.contains(2),
      contains10: this.contains(10),
      delNode: this.lastRemovedNode
    })
  }

  printDFS() {
    if (!this.root) {
      console.log("Can't print empty tree")
      return
    }

    let stack = [this.root]
    let node

    while (stack.length > 0) {
      let child1, child2;
      let node = stack.shift()

      if (node.left) {
        child1 = node.left.value
        stack.unshift(node.left)
      } else {
        child1 = "NULL"
      }

      if (node.right) {
        child2 = node.right.value
        stack.unshift(node.right)
      } else {
        child2 = "NULL"
      }
      console.log(`[${node.value}] -> [${child1}, ${child2}]`)
    }
  }

  isFull() {
    let queue = []
    let currentNode

    if (!this.root) return false
    queue = [this.root]

    while (queue.length > 0) {
      currentNode = queue.shift()
      if ( currentNode.left === null && currentNode.right === null ) {
        queue.shift()
        continue
      } else if( currentNode.left && currentNode.right ) {
        queue = [...queue, currentNode.left, currentNode.right]
      } else {
        return false
      }
    }

    return true
  }

  isPerfect() {
    let penultimateDepth = this.depth() - 2
    let penultimateCount = Math.pow(2, penultimateDepth)
    let nodesByDepth = this._graphReduceByLevel()
    return nodesByDepth[penultimateDepth].length === penultimateCount
  }

  _graphReduceByLevel() {
    if (!this.root) return false

    let queue = [0, this.root]
    let currentNode, level
    let summary = {}

    while (queue.length > 0) {
      level = queue.shift()
      currentNode = queue.shift()

      if (level in summary) {
        summary[level].push(currentNode)
      } else {
        summary[level] = [currentNode]
      }

      if (currentNode.left) queue.push(level + 1, currentNode.left)
      if (currentNode.right) queue.push(level + 1, currentNode.right)
    }

    return summary
  }
}

module.exports =  BST